## 异步问题

​	异步语法的目标是**怎样让它看起来更像同步编程**。

#### Promise

​	异步函数通常都会设置**回调函数(callack)**作为触发异步任务时的执行函数，但这样很容易造成多重嵌套，也就是所谓的**“回调地狱”**。例如，当我们想读取A文件后再读取B文件，则有：

```javascript
fs.readFile(fileA, function (err, data) {
  fs.readFile(fileB, function (err, data) {
  //异步函数的执行分成两段，第二段是回调函数，程序无法捕捉两端之间的错误，只能作为参数err传入第二
  //段
    ...
  });
});
```

这样的嵌套会是代码无法管理，也就有了**promise**：

```javascript
let p = new Promise((resolve,reject) => {
			resolve('a new promise');
    		reject('a new promise');
		}).then((data) => {
			console.log(data + ' resolve!');
		}).catch((data) => {
			console.log(data + ' reject!');
		});
```

##### Promise具有两个特点：

​	1.对象状态不受外界影响，只有最终的执行结果可以改变状态，这也对应了”Promise“这个名字；

​	2.状态一旦改变，那就不会再改变，只能从**pending(等待)**变为**fulfilled(已成功，由resolve函数触发)**和**rejected(已失败，由reject函数触发)**这两种状态，且任何时候都能获取到。



promise最大的特点和作用在于避免了回调地狱，同时把异步操作的执行代码和处理结果分开执行(then方法)，**但是**promise本质仍是语法糖，对性能提升并无显著作用，而且很多个then方法也容易让人有不知所云的感觉，所以**并非是解决异步问题的最优解**。



有一种思想叫做**”协程“**，意思是多个线程互相协作，完成异步任务，流程大致如下：

​	第一步，协程A开始执行；

​	第二步，协程A执行到一半，进入暂停，执行权转移到协程B；

​	第三步，（一段时间后）协程B交还执行权；

​	第四步，协程A恢复执行；



这种想法的具体实现者是**Generator函数**，例：

```javascript
		function* gen(x){
          try{
		  	var y = yield x + 2;	// yield是执行权移交标志，表明异步操作会在此暂停，并执行yield之后的代码，等执行完成后再继续generaotr后的代码执行,yield后只能接Thunk函数和promise对象
          }catch（e）{
          	console.log(e);
          }
          return y;
		}
		var g = gen(1);	// 返回的g是一个遍历器，代表通过调用next方法可以查明不同阶段的执行结果
		console.log(g.next());	//	{ value: 3, done: false }
		g.throw('a mistake')	// 显示trycatch捕获的错误
```



#### 基于Thunk函数的自动执行

​	javascript采用“传值调用”策略（即**向一个函数传入参数时先算出参数表达式的值**，是一种**事先准备策略**），Thunk函数采用“传名调用”策略（即**向一个函数直接传入表达式，参数的具体值在需要时才去计算**）。

```js
function gen(x){
	return x+1;
}
var a = 1;
gen(a+1);//	此处先计算出a+1的值
```

​	而在JavaScript中，Thunk函数是把**多参数函数**替换为**单参数函数**，只接受**回调函数**作为参数，同时也作为**执行权返回给generator**的手段。

​	Thunk函数在Generator函数中的作用是可以**作为自动执行器**，不需要一直手动调用next函数就能自动进入下一个阶段。例：

```javascript
const fs = require('fs');
const thunkify = require('thunkify');
const readFile = thunkify(fs.readFile);

var gen = function* (){
  var r1 = yield readFile('./demo1.txt');
  //console.log(r1.toString());
  var r2 = yield readFile('./demo2.txt');
  //console.log(r2.toString());
};

function run(fn) {
  var gen = fn();

  function next(err, data) {
    var result = gen.next(data);
    if (result.done) return;
    result.value(next);	//thunk调用回调函数执行下一步
  }

  next();
}

run(gen);
```



#### co函数库

​	自动执行Generator函数的小工具，最终返回一个**Promise对象**，可以用**then方法显示结果和交回执行权**。

​	**co 函数库其实就是将两种自动执行器（Thunk 函数和 Promise 对象），包装成一个库。**使用 co 的前提条件是，Generator 函数的 yield 命令后面，只能是 Thunk 函数或 Promise 对象。



#### 基于Promise的自动执行

```javascript
const fs = require('fs');


var readfile = function (filename) {
	return new Promise(function (resolve,reject) {
		fs.readFile(filename, function (err,data) {
			if (err) reject(err);
			resolve(data);
		});
	})
}

var gen = function* (){
  var r1 = yield readfile('./demo1.txt');
  console.log(r1.toString());
  var r2 = yield readfile('./demo2.txt');
  console.log(r2.toString());
};

var g = gen();

function run(fn) {
  var g = fn();

  function next(data) {
    var result = g.next(data);
    if (result.done) return result.value;
    result.value.then(function (data) {
      next(data);
    });
  }

  next();
}

g.next().value.then(function(data){
	console.log(data);
  g.next(data).value.then(function(data){
  	console.log(data);
    g.next(data);
  });
})

//<Buffer 69 20 61 6d 20 64 65 6d 6f 31>
//i am demo1
//<Buffer 69 20 61 6d 20 64 65 6d 6f 32>
//i am demo2
//数据流先于console结果出现，证明执行权从异步交回到了generator函数
```

**但是Generator函数也存在表意不明，yield后只能跟Thunk函数和Promise对象，且流程管理不方便，无法明白何时执行各阶段的代码**



**最终异步的最优解其实是async/await**



